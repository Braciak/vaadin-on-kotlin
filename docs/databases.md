[Index](index.html) | [Getting Started](gettingstarted.html) | [Guides](vok-guides.html)

# Accessing SQL databases with Vaadin-on-Kotlin

Vaadin-on-Kotlin provides first-class support for the following SQL databases out-of-the-box:

* [H2 Database](http://h2database.com) - a 100% Java database which can be quick-started as an in-memory
  database; perfect for writing tests for your app.
* [PostgreSQL](https://www.postgresql.org/)
* [MariaDB](https://mariadb.org/)
* [MySQL](https://www.mysql.com/)

All other SQL databases may or may not work. Care has been taken to only use the SQL92 syntax,
but we only test and officially support the four of the above-mentioned databases.

> *NoSQL Note*: Only SQL databases which provide appropriate JDBC drivers are currently supported.
There is no direct support for NoSQL databases, but you can easily integrate any NoSQL database with VoK.

> *Note for experienced Java developers*: Experienced Java developers will notice that VoK is *not* using JPA nor Hibernate to access the
database. The reason is that there are inherent issues with the abstraction that JPA
mandates - you can read more about the topic in the [Why Not JPA](http://mavi.logdown.com/posts/5771422) article.

## Basic CRUD ORM

The above horrific acronym stands for inserting, querying and deleting rows from your database,
and mapping those rows into Kotlin objects so that they are easy to work with.

The "CRUD" stands for [Create, read, update and delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) -
the four basic operations performed on a collection of entities mapped to the database, such as a
collection of `Person`s.

The ORM stands for Object-Relational Mapping and stands for mapping database rows into Kotlin objects,
for easier use from within your application. VoK does not use JPA but instead features
a new, vastly simplified database access layer called `vok-orm`.

## About vok-orm

`vok-orm` is a very simple object-relational mapping library, built around the following ideas:

* Simplicity is the most valued property; working with plain SQL commands is preferred over having a type-safe
  query language.
* Kotlin objects merely capture JDBC `ResultSet` rows, by the means of invoking appropriate setters (based on the column name) via
  Java reflection. 
* The entities are just plain objects: they do not track modifications as JPA entities do,
  they do not automatically store modified
  values back into the database. They are never runtime-enhanced and can be final.
* A switch from one type of database to another never happens. We understand that the programmer
  wants to exploit the full potential of the database, by writing SQLs tailored for that particular database.
  `vok-orm` should not attempt to generate SELECTs on behalf of the programmer (except for the very basic ones related to CRUD);
  instead it should simply allow SELECTs to be passed as Strings, and then map the result
  to an object of programmer's choosing.

Because of its simple design principles, `vok-orm` supports not just mapping tables to Kotlin classes,
but it allows mapping of any complex SELECT with joins and everything, even VIEWs, into Kotlin classes.
Naturally this allows you to use any SELECT inside of a Vaadin Grid component which is a
very powerful combination. 

## Persisting simple objects into tables

Please read the [Usage examples](https://github.com/mvysny/vok-orm#usage-examples) chapter of
the `vok-orm` documentation on how to write Kotlin classes that correspond to a particular SQL database
table, and how to create rows in that particular database tables.

> Note: please read the [Getting Started Guide](gettingstarted.md) on information where to put
all of these files and SQL scripts.

Let us have a `Person` table with the following columns:

| Column | Type | Meaning
| ------ | ---- | ---------
| id | Long? | The primary key, automatically generated by the database, not null. The Kotlin type is nullable since we don't know the ID yet when the person is just being created.
| name | String | The full name of the person, not null.
| age | Int | The age, not null.
| dateOfBirth | LocalDate? | The date of birth, nullable.
| alive | Boolean | Whether the person is alive or deceased.
| maritalStatus | MaritalStatus? | The Marital status. Demoes binding to enum constants.
| modified | Instant? | When the record was last modified in the database

The marital status enum definition is simple:

```kotlin
enum class MaritalStatus { Single, Married, Divorced, Widowed }
```

The PostgreSQL DDL script which creates such table is simple:
```postgresql
create table Person (
    id bigserial primary key,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp not null
)
```

The MySQL/MariaDB DDL script:
```mysql
create table Person (
    id bigint primary key auto_increment,
    name varchar(400) not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar(200),
    modified timestamp(3) not null
)
```

Finally, the H2 script:
```h2
create table Person (
    id bigint primary key auto_increment,
    name varchar not null,
    age integer not null,
    dateOfBirth date,
    alive boolean not null,
    maritalStatus varchar,
    modified timestamp not null
)
```

> *MaritalStatus Note*: We will store the enum name into the database, e.g. "Single", instead of
just ordinal value of the constant (e.g. 0). The ordinal is easy to accidentally change by the programmer,
e.g. by reordering the enum constants. The data will still load, but it will silently show incorrect
information which is disastrous.

The Kotlin class which maps to this table is as follows:

```kotlin
data class Person(
    override var id: Long? = null,
    var name: String,
    var age: Int,
    var dateOfBirth: LocalDate? = null,
    var alive: Boolean = null,
    var maritalStatus: MaritalStatus,
    var modified: Instant? = null
) : Entity<Long> {
    override fun save() {
        modified = Instant.now()
        super.save()
    }

    companion object : Dao<Person>
}
```

By implementing the `Entity` interface the Kotlin class gains capability to create/update itself into
the database; by having the companion object to implement the `Dao` interface the Kotlin class
gains the lookup capabilities, for example:

```kotlin
fun main() {
    val person = Person(name = "John Doe", age = 42, alive = false, maritalStatus = MaritalStatus.Single)
    person.save()  // since ID is null, this will create the person and populate the ID
    println(Person.findAll())  // will print [Person(id=1, name=John Doe, age=42 etc)]
    println(Person.getById(person.id!!))  // will print Person(id=1, name=John Doe, age=42 etc)
    person.name = "Agent Smith"
    person.save()   // will update the person in the database, also updating the `modified` field
    println(Person.findById(25L)) // will print null since there is no such person yet
    Person.deleteAll()   // will delete all personnel
    Person.deleteById(42L)   // will delete a person with ID of 42
    println(Category.count()) // will print 0 since we deleted everything
    println(Person.findBy { "name = :name1 or name = :name2"("name1" to "John Doe", "name2" to "Agent Smith") })   // will print []
    Person.deleteBy { (Person::name eq "Agent Smith") }  
    Person.getBy { "name = :name"("name" to "Agent Smith") }   // will fetch exactly one matching person, failing if there is no such person or there are more than one.
    Person.findSpecificBy { "name = :name"("name" to "Agent Smith") } // will fetch one matching person, failing if there are more than one. Returns null if there is none.
}
```

For more information please read the [vok-orm documentation](https://github.com/mvysny/vok-orm).

## Forms

Forms allows the user to enter the values of a newly created record, or edit the values of
already existing ones. Validation is typically employed, to guide the user to enter
meaningful data.

todo how VoK encourages you to write validating forms which map values to your beans and how
you can update new valies in the database.

## Using `vok-orm` with Vaadin Grid

Vaadin Grid is a very powerful component which allows you to show a lazy-loaded list of rows
on a web page. It allows the user to:

* efficiently scroll the list, lazy-loading more data as they are scrolled into the viewport,
* sorting by one or more columns (shift-click the caption to add sorting columns)
* filtering from code
* VoK provides means to auto-generate filter components and auto-populate them into the Grid,
  which provides you with a simple means to allow the user to filter as well.

You can find more information about the Vaadin Grid at the [Vaadin Grid Documentation](http://wc.demo.vaadin.com/mcm/out/framework/components/components-grid.html) page.

